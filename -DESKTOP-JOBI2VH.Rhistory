Bfuncs <- model$Bfuncs
Mmax <- length(Bfuncs) - 1
# Compute predicted values using basis functions
y_pred <- B[, 1]  # Initialize with intercept
for (M in 1:Mmax) {
splits <- Bfuncs[[M]]
for (i in 1:nrow(splits)) {
v <- splits[i, 2]
t <- splits[i, 3]
if (splits[i, 1] == -1) {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] > t)
} else {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] <= t)
}
}
}
return(y_pred)
}
# Test the plot function
plot_mars_model(mars_model, cbind(y, x)))
#---------------------------------------------------
# Define a function to plot basis functions, splits, and fitted line
plot_mars_model <- function(model, data) {
Bfuncs <- model$Bfuncs
n <- ncol(data) - 1  # Number of predictors
# Initialize a plot with appropriate limits
plot(data[, -1], col = "blue", pch = 19, xlab = "x1", ylab = "x2", main = "MARS Model", xlim = range(data[, "x1"]), ylim = range(data[, "x2"]))
# Loop over basis functions
for (i in 1:length(Bfuncs)) {
splits <- Bfuncs[[i]]
# Check if splits is empty
if (nrow(splits) == 0) {
next  # Skip to the next iteration if splits is empty
}
# Loop over splits
for (j in 1:nrow(splits)) {
v <- splits[j, 2]
t <- splits[j, 3]
if (splits[j, 1] == -1) {
abline(v = t, col = "red", lty = "dashed")
} else {
abline(h = t, col = "red", lty = "dashed")
}
}
}
# Predict values using the MARS model
x <- data[, -1]
y_pred <- predict_mars(model, x)
# Plot fitted line
lines(x[, 1], y_pred, col = "green")
}
# Function to predict using the MARS model
predict_mars <- function(model, newdata) {
B <- model$B
Bfuncs <- model$Bfuncs
Mmax <- length(Bfuncs) - 1
# Compute predicted values using basis functions
y_pred <- B[, 1]  # Initialize with intercept
for (M in 1:Mmax) {
splits <- Bfuncs[[M]]
for (i in 1:nrow(splits)) {
v <- splits[i, 2]
t <- splits[i, 3]
if (splits[i, 1] == -1) {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] > t)
} else {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] <= t)
}
}
}
return(y_pred)
}
# Test the plot function
plot_mars_model(mars_model, cbind(y, x))
# Define a function to perform MARS regression
mars_regression <- function(y, x, Mmax) {
N <- length(y)  # sample size
n <- ncol(x)    # number of predictors
B <- init_B(N, Mmax)  # Initialize basis functions
# Initialize list to store splits
Bfuncs <- vector("list", length = Mmax + 1)
# Loop for forward selection
for (M in 1:Mmax) {
lof_best <- Inf
for (m in 1:M) {
for (v in 1:n) {
# Select a variable to split on
tt <- split_points(x[, v], B[, m])
for (t in tt) {
# Update basis functions
Bnew <- data.frame(B[, -(1:M)[-m]],
Btem1 = B[, m] * (x[, v] > t),
Btem2 = B[, m] * (x[, v] <= t))
gdat <- data.frame(y = y, Bnew)
lof <- LOF(y ~ ., gdat)
if (lof < lof_best) {
lof_best <- lof
best_split <- c(m = m, v = v, t = t)
}
}
}
}
# Update basis functions with the best split
mstar <- best_split["m"]; vstar <- best_split["v"]; tstar <- best_split["t"]
B[, M + 1] <- B[, mstar] * H(-1, x[, vstar] - tstar)
B[, mstar] <- B[, mstar] * H(+1, x[, vstar] - tstar)
Bfuncs[[M + 1]] <- rbind(Bfuncs[[mstar]], c(-1, vstar, tstar))
Bfuncs[[mstar]] <- rbind(Bfuncs[[mstar]], c(+1, vstar, tstar))
}
return(list(B = B, Bfuncs = Bfuncs))
}
# Function to initialize basis functions
init_B <- function(N, Mmax) {
B <- data.frame(matrix(NA, nrow = N, ncol = (Mmax + 1)))
B[, 1] <- 1  # first column for intercept
names(B) <- c("B0", paste0("B", 1:Mmax))
return(B)
}
# Function to calculate LOF
# Function to calculate LOF
LOF <- function(form, data) {
if (sum(!is.na(data$y)) == 0 || nrow(data) < 3) {
return(Inf)  # Return infinity if there are zero non-NA cases or less than 3 cases
} else {
ff <- try(lm(form, data), silent = TRUE)  # Use try() to catch potential errors during model fitting
if (inherits(ff, "try-error")) {
return(Inf)  # Return infinity if there is an error during model fitting
} else {
return(sum(residuals(ff)^2))
}
}
}
# Function to calculate split points
split_points <- function(xv, Bm) {
out <- sort(unique(xv[Bm > 0]))
return(out[-length(out)])
}
# Define H function
H <- function(s, diff) {
eta <- s * diff
if (s == 1) {
out <- as.numeric(eta > 0)
}
if (s == -1) {
out <- as.numeric(eta >= 0)
}
return(out)
}
# Test
set.seed(123)
n <- 10
x <- data.frame(x1 = rnorm(n), x2 = rnorm(n))
y <- rnorm(n)
mars_model <- mars_regression(y, x, Mmax = 9)
mars_model$Bfuncs
#---------------------------------------------------
# Define a function to plot basis functions, splits, and fitted line
plot_mars_model <- function(model, data) {
Bfuncs <- model$Bfuncs
n <- ncol(data) - 1  # Number of predictors
# Initialize a plot with appropriate limits
plot(data[, -1], col = "blue", pch = 19, xlab = "x1", ylab = "x2", main = "MARS Model", xlim = range(data[, "x1"]), ylim = range(data[, "x2"]))
# Loop over basis functions
for (i in 1:length(Bfuncs)) {
splits <- Bfuncs[[i]]
# Check if splits is empty
if (nrow(splits) == 0) {
next  # Skip to the next iteration if splits is empty
}
# Loop over splits
for (j in 1:nrow(splits)) {
v <- splits[j, 2]
t <- splits[j, 3]
if (splits[j, 1] == -1) {
abline(v = t, col = "red", lty = "dashed")
} else {
abline(h = t, col = "red", lty = "dashed")
}
}
}
# Predict values using the MARS model
x <- data[, -1]
y_pred <- predict_mars(model, x)
# Plot fitted line
lines(x[, 1], y_pred, col = "green")
}
# Function to predict using the MARS model
predict_mars <- function(model, newdata) {
B <- model$B
Bfuncs <- model$Bfuncs
Mmax <- length(Bfuncs) - 1
# Compute predicted values using basis functions
y_pred <- B[, 1]  # Initialize with intercept
for (M in 1:Mmax) {
splits <- Bfuncs[[M]]
for (i in 1:nrow(splits)) {
v <- splits[i, 2]
t <- splits[i, 3]
if (splits[i, 1] == -1) {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] > t)
} else {
y_pred <- y_pred + B[, M + 1] * (newdata[, v] <= t)
}
}
}
return(y_pred)
}
# Test the plot function
plot_mars_model(mars_model, cbind(y, x))
x1 <- c(2.16,5.3,9.32,6.39,9.79,7.59,4.21,4.88,2.33,1.12)
x2 <- c(3.57,2.86,5.4,2.96,3.69,3.03,2.26,3.19,1.2,4.47)
x3 <- c(0.09,0.9,-0.11,1.26,-9.27,-1.01,1.06,0.62,1.54,0.48)
df <- data.frame(x1,x2,x3)
df
simple_reduce <- function(x,f) {
out <- x[[1]]
for (i in seq(2, length(x))){
out <- f(out,x[[i]])
}
out
}
x1 <- c(2.16,5.3,9.32,6.39,9.79,7.59,4.21,4.88,2.33,1.12)
x2 <- c(3.57,2.86,5.4,2.96,3.69,3.03,2.26,3.19,1.2,4.47)
x3 <- c(0.09,0.9,-0.11,1.26,-9.27,-1.01,1.06,0.62,1.54,0.48)
df <- data.frame(x1,x2,x3)
simple_reduce(lapply(df,max), cbind)
new_mars.control <- function(control) {
structure(control, class="mars.control")}
validate_mars.control <- function(control) {
stopifnot(is.integer(control$Mmax),is.numeric(control$d),
is.logical(control$trace))
if(control$Mmax < 2) {
warning("Mmax must be >= 2; Reset it to 2")
control$Mmax <- 2}
if(control$Mmax %% 2 > 0) {
control$Mmax <- 2*ceiling(control$Mmax/2)
warning("Mmax should be an even integer. Reset it to ",control$Mmax)}
control
}
mars.control <- function(Mmax=2,d=3,trace=FALSE) {
Mmax <- as.integer(Mmax)
control <- list(Mmax=Mmax,d=d,trace=trace)
control <- validate_mars.control(control)
new_mars.control(control)
}
mc <- mars.control()
#-------------------------------------------------------------------------------
set.seed(123); n <- 10
data <- data.frame(x1=rnorm(n),x2=rnorm(n),y=rnorm(n))
formula <- formula(y ~.)
mf = model.frame(formula, data) # returns a data frame with variables needed
y = model.response(mf)          # returns the response from the model frame
mt = attr(mf, "terms")          # obtains attributes of the model frame
x = model.matrix(mt, mf)        # creates a design matrix
x <- x[, -1]  # Remove the first column (intercept)
head(x)
mars <- function(formula, data, mc) {
mf <- model.frame(formula, data)
y <- model.response(mf)
mt <- attr(mf, "terms")
x <- model.matrix(mt, mf)[, -1]  # Remove the intercept column
result <- fwd_stepwise(y, x, mc)
return(result)
}
#-------------------------------------------------------------------------------
h <- function(x,s,t) {
# if x>t, s=+1, this return max(0,x-t)
# if x<t, s=-1, this return max(0,t-x)
return(pmax(0,s*(x-t)))
}
#-------------------------------------------------------------------------------
# LOF <- function(form,data) {
#  ff <- lm(form,data)
#  return(sum(residuals(ff)^2))
# }
LOF <- function(form,data,control) {
ff <- lm(form,data)
RSS <- sum(residuals(ff)^2)
N <- nrow(data)
M <- length(coef(ff))-1
Ctilde <- sum(diag(hatvalues(ff))) + control$d*M
return(RSS * N/(N-Ctilde)^2)
}
init_B <- function(N,Mmax) {
# Input: N- # of rows; Mmax: # of basis funcs
# output: a N by (Mmax+1) dataframe
B <- data.frame( matrix(NA,nrow=N,ncol=(mc$Mmax+1)) )
B[, 1] <- 1 # first column for intercept: B0
B[, -1] <- 0  # Initialize other columns to 0
names(B) <- c("B0",paste0("B",1:Mmax))
return(B)
}
split_points <- function(xv,Bm) {
# input: xv: a variable xv to split
#        Bm: a parent basis func to split
# output: feasible splitting points
#
out <- sort(unique(xv[Bm>0]))
return(out[-length(out)])
}
#-------------------------------------------------------------------------------
fwd_stepwise <- function(y,x,mc){
N <- length(y) # sample size
n <- ncol(x) # number of predictors
Mmax <- mc$Mmax
B <- init_B(N,Mmax) # initiate B dataframe
Bfuncs <- vector("list", length = mc$Mmax+1)
#-------------------------------------------------------------------------------
# Looping for forward selection:
# Replace the M loop with a loop over pairs i, and set the value of M from the value of i.
for(i in 1:(Mmax/2)) {
M <- 2 * i - 1 # Set the value of M from the value of i
if(mc$trace) cat("M",M,"\n")
lof_best <- Inf
for(m in 1:M) { # choose a basis function to split
svars <- setdiff(1:n, Bfuncs[[m]][, "v"]) # store the indices of variables that are not already in basis function m
if (mc$trace) cat("M, m, svars", M, m, svars, "\n")
for(v in svars){ # select a variable to split on
tt <- split_points(x[,v],B[,m])
for(t in tt) {
Bnew <- data.frame(B[,1:M],
# replace parent B[,m] with Btem1,Btem2
Btem1 = h(x[, v], +1, t) * B[, m],
Btem2 = h(x[, v], -1, t) * B[, m])
gdat <- data.frame(y=y,Bnew)
lof <- LOF(form = y ~ ., data = gdat, control = mc) #  Use the LOF() given below
if(lof < lof_best) {
lof_best <- lof
split_best <- c(m=m, v=v, t=t)
} # end if
} # end loop over splits
} # end loop over variables
} # end loop over basis functions to split
mstar <- split_best["m"]; vstar <- split_best["v"]; tstar <- split_best["t"]
cat("[Info] best (m,v,t,lof): (",mstar,vstar,tstar,lof_best,")\n")
#-------------------------------------------------------------------------------
B[, M + 1] <- B[, mstar] * h(x[, vstar], -1, tstar)
B[, M + 2] <- B[, mstar] * h(x[, vstar], +1, tstar)
Bfuncs[[M + 1]] = rbind(Bfuncs[[mstar]], c(-1, vstar, tstar)) # Add left child basis function
Bfuncs[[M + 2]] = rbind(Bfuncs[[mstar]], c(+1, vstar, tstar)) # Update parent basis with the right child basis
colnames(Bfuncs[[M + 1]]) <- colnames(Bfuncs[[M + 2]]) <- c("s", "v", "t")
#-------------------------------------------------------------------------------
} # end for loop over i
colnames(B) <- paste0("B",0:(ncol(B)-1))
return(list(y=y,B=B,Bfuncs=Bfuncs))
}
fwd <- fwd_stepwise(y, x, mc)
plot.mars <- function(x, ...) {
B <- x$B
Bfuncs <- x$Bfuncs
# Get dimensions
n <- ncol(B)
# Create meshgrid for plotting
xvals <- sort(seq(min(B[,1]), max(B[,1]), length.out = 50))
yvals <- sort(seq(min(B[,2]), max(B[,2]), length.out = 50))
z <- matrix(NA, nrow = length(xvals), ncol = length(yvals))
# Evaluate each basis function on the meshgrid and sum them up
for (i in 1:length(xvals)) {
for (j in 1:length(yvals)) {
pred <- 0
for (k in 1:n) {
func <- Bfuncs[[k]]
if (length(func) == 0) {
next  # Skip empty basis function
}
pred <- pred + func[1] * h(xvals[i], func[2], func[3]) * h(yvals[j], func[2], func[3])
}
z[j, i] <- pred  # Note the reversal of indices for compatibility with persp
}
}
# Plot the surface
persp(xvals, yvals, z, col = "lightblue", main = "MARS Basis Functions", xlab = "X", ylab = "Y", zlab = "Z", ...)
}
fwd_result <- fwd_stepwise(y, x, mc)
plot.mars(fwd_result)
load("TestFiles/mctest.RData")
setwd("~/STAT_360/GitHub/GitHub/MarsProject")
load("TestFiles/mctest.RData")
load("TestFiles/xtest.RData")
load("TestFiles/fwdtest.RData")
library(stats)
getwd()
# load("TestFiles/testfwd_stepwise.RData")
#-------------------------------------------------------------------------------
# Constructor for `mars.control` objects
new_mars.control <- function(control) {
structure(control, class="mars.control")}
validate_mars.control <- function(control) {
stopifnot(is.integer(control$Mmax),is.numeric(control$d),
is.logical(control$trace))
if(control$Mmax < 2) {
warning("Mmax must be >= 2; Reset it to 2")
control$Mmax <- 2}
if(control$Mmax %% 2 > 0) {
control$Mmax <- 2*ceiling(control$Mmax/2)
warning("Mmax should be an even integer. Reset it to ",control$Mmax)}
control
}
mars.control <- function(Mmax=2,d=3,trace=FALSE) {
Mmax <- as.integer(Mmax)
control <- list(Mmax=Mmax,d=d,trace=trace)
control <- validate_mars.control(control)
new_mars.control(control)
}
mc <- mars.control()
all.equal(mc, mctest) # should return 'TRUE'
#-------------------------------------------------------------------------------
set.seed(123); n <- 10
data <- data.frame(x1=rnorm(n),x2=rnorm(n),y=rnorm(n))
formula <- formula(y ~.)
mf = model.frame(formula, data) # returns a data frame with variables needed
y = model.response(mf)          # returns the response from the model frame
mt = attr(mf, "terms")          # obtains attributes of the model frame
x = model.matrix(mt, mf)        # creates a design matrix
x <- x[, -1]  # Remove the first column (intercept)
is_equal <- all.equal(x, xtest) # check implementation
head(x)
print(is_equal) # should return 'TRUE'
mars <- function(formula, data, mc) {
mf <- model.frame(formula, data)
y <- model.response(mf)
mt <- attr(mf, "terms")
x <- model.matrix(mt, mf)[, -1]  # Remove the intercept column
result <- fwd_stepwise(y, x, mc)
return(result)
}
#-------------------------------------------------------------------------------
h <- function(x,s,t) {
# if x>t, s=+1, this return max(0,x-t)
# if x<t, s=-1, this return max(0,t-x)
return(pmax(0,s*(x-t)))
}
#-------------------------------------------------------------------------------
# LOF <- function(form,data) {
#  ff <- lm(form,data)
#  return(sum(residuals(ff)^2))
# }
LOF <- function(form,data,control) {
ff <- lm(form,data)
RSS <- sum(residuals(ff)^2)
N <- nrow(data)
M <- length(coef(ff))-1
Ctilde <- sum(diag(hatvalues(ff))) + control$d*M
return(RSS * N/(N-Ctilde)^2)
}
init_B <- function(N,Mmax) {
# Input: N- # of rows; Mmax: # of basis funcs
# output: a N by (Mmax+1) dataframe
B <- data.frame( matrix(NA,nrow=N,ncol=(mc$Mmax+1)) )
B[, 1] <- 1 # first column for intercept: B0
B[, -1] <- 0  # Initialize other columns to 0
names(B) <- c("B0",paste0("B",1:Mmax))
return(B)
}
split_points <- function(xv,Bm) {
# input: xv: a variable xv to split
#        Bm: a parent basis func to split
# output: feasible splitting points
#
out <- sort(unique(xv[Bm>0]))
return(out[-length(out)])
}
#-------------------------------------------------------------------------------
fwd_stepwise <- function(y,x,mc){
N <- length(y) # sample size
n <- ncol(x) # number of predictors
Mmax <- mc$Mmax
B <- init_B(N,Mmax) # initiate B dataframe
Bfuncs <- vector("list", length = mc$Mmax+1)
#-------------------------------------------------------------------------------
# Looping for forward selection:
# Replace the M loop with a loop over pairs i, and set the value of M from the value of i.
for(i in 1:(Mmax/2)) {
M <- 2 * i - 1 # Set the value of M from the value of i
if(mc$trace) cat("M",M,"\n")
lof_best <- Inf
for(m in 1:M) { # choose a basis function to split
svars <- setdiff(1:n, Bfuncs[[m]][, "v"]) # store the indices of variables that are not already in basis function m
if (mc$trace) cat("M, m, svars", M, m, svars, "\n")
for(v in svars){ # select a variable to split on
tt <- split_points(x[,v],B[,m])
for(t in tt) {
Bnew <- data.frame(B[,1:M],
# replace parent B[,m] with Btem1,Btem2
Btem1 = h(x[, v], +1, t) * B[, m],
Btem2 = h(x[, v], -1, t) * B[, m])
gdat <- data.frame(y=y,Bnew)
lof <- LOF(form = y ~ ., data = gdat, control = mc) #  Use the LOF() given below
if(lof < lof_best) {
lof_best <- lof
split_best <- c(m=m, v=v, t=t)
} # end if
} # end loop over splits
} # end loop over variables
} # end loop over basis functions to split
mstar <- split_best["m"]; vstar <- split_best["v"]; tstar <- split_best["t"]
cat("[Info] best (m,v,t,lof): (",mstar,vstar,tstar,lof_best,")\n")
#-------------------------------------------------------------------------------
B[, M + 1] <- B[, mstar] * h(x[, vstar], -1, tstar)
B[, M + 2] <- B[, mstar] * h(x[, vstar], +1, tstar)
Bfuncs[[M + 1]] = rbind(Bfuncs[[mstar]], c(-1, vstar, tstar)) # Add left child basis function
Bfuncs[[M + 2]] = rbind(Bfuncs[[mstar]], c(+1, vstar, tstar)) # Update parent basis with the right child basis
colnames(Bfuncs[[M + 1]]) <- colnames(Bfuncs[[M + 2]]) <- c("s", "v", "t")
#-------------------------------------------------------------------------------
} # end for loop over i
colnames(B) <- paste0("B",0:(ncol(B)-1))
return(list(y=y,B=B,Bfuncs=Bfuncs))
}
fwd <- fwd_stepwise(y, x, mc)
source("fwd_stepwise.R")
source("R/fwd_stepwise.R")
fwd
